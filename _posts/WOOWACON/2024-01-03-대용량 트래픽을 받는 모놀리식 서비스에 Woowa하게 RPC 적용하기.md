---
layout: single
title: "대용량 트래픽을 받는 모놀리식 서비스에 Woowa하게 RPC 적용하기"
categories: conference
tag: [conference, woowacon]
toc: true
toc_sticky: true
author_profile: false
---
## RPC (Remote Procedure Call)

* 컴퓨터 네트워크에서 사용되는 프로토콜로, 한 컴퓨터에서 다른 컴퓨터에 있는 프로시저(함수)를 마치 로컬 프로시저처럼 호출할 수 있게 해줍니다. RPC는 분산 컴퓨팅과 클라우드 서비스에서 널리 사용되며, 네트워크를 통해 다른 컴퓨터의 리소스와 서비스를 이용할 수 있게 하는 중요한 기술입니다.

* RPC의 특징은 다음과 같습니다.

1. **클라이언트-서버 모델**: RPC는 클라이언트-서버 모델을 기반으로 합니다. 클라이언트는 서비스를 요청하고, 서버는 그 요청을 처리하여 결과를 반환합니다.
2. **투명성**: 클라이언트는 원격으로 호출되는 프로시저가 로컬에서 실행되는 것처럼 인식합니다. 네트워크 세부 사항은 숨겨져 있으며, 클라이언트는 프로시저의 위치를 몰라도 됩니다.
3. **직렬화 및 역직렬화**: 데이터는 네트워크를 통해 전송될 수 있도록 직렬화되어야 하며, 서버 측에서는 이 데이터를 역직렬화하여 사용합니다. 이 과정은 데이터를 네트워크 친화적인 형태로 변환하는 과정입니다.
4. **언어 및 플랫폼 독립성**: 많은 RPC 시스템은 다양한 프로그래밍 언어와 플랫폼에서 작동할 수 있도록 설계되었습니다. 이는 서로 다른 시스템 간의 상호 운용성을 가능하게 합니다.
5. **동기식 및 비동기식 RPC**: RPC는 동기식(클라이언트가 응답을 기다리는) 또는 비동기식(클라이언트가 다른 작업을 계속하면서 응답을 기다리는) 방식으로 작동할 수 있습니다.

* RPC는 네트워크 지연, 데이터 포맷 호환성, 보안 문제 등 다양한 도전 과제를 가지고 있습니다. 그러나 이를 통해 시스템 간의 통합과 자원 공유를 용이하게 하며, 복잡한 네트워크 프로그래밍 없이 원격 서비스를 손쉽게 이용할 수 있게 합니다.



## gRPC

* Google에서 개발한 고성능, 오픈 소스, 범용 RPC(원격 프로시저 호출) 프레임워크입니다. gRPC는 클라이언트와 서버 간에 효율적인, 언어 중립적인 방식으로 데이터를 교환할 수 있게 설계되었으며, 특히 마이크로서비스 아키텍처와 같은 분산 시스템 환경에서 강력한 성능을 제공합니다.

* gRPC의 주요 특징과 장점은 다음과 같습니다.

1. **언어 중립적 인터페이스 정의**: gRPC는 Protocol Buffers(proto)를 사용하여 서비스 인터페이스와 메시지 구조를 정의합니다. Protocol Buffers는 언어 중립적이고, 효율적인 데이터 직렬화 형식을 제공합니다.
2. **다양한 언어 지원**: gRPC는 C++, Java, Python, Go, Ruby, C#, Node.js 등 다양한 프로그래밍 언어를 지원합니다. 이를 통해 서로 다른 언어로 작성된 서비스 간의 통신을 용이하게 합니다.
3. **빠른 성능**: gRPC는 HTTP/2를 사용하여 클라이언트와 서버 간 통신을 처리합니다. 이는 전통적인 HTTP/1.1 기반의 통신보다 효율적이며, 더 빠른 데이터 전송과 낮은 지연 시간을 제공합니다.
4. **양방향 스트리밍**: gRPC는 서버와 클라이언트가 동시에 스트림을 시작하고 메시지를 주고받을 수 있는 양방향 스트리밍을 지원합니다. 이는 실시간 통신과 같은 시나리오에서 유용합니다.
5. **강력한 인터페이스**: gRPC는 강력한 타입의 인터페이스를 제공하며, 컴파일 시간에 인터페이스 계약을 검증할 수 있습니다. 이는 버그를 줄이고 시스템의 안정성을 높입니다.
6. **효율적인 네트워크 사용**: gRPC의 Protocol Buffers 직렬화는 JSON이나 XML보다 훨씬 효율적이며, 데이터 크기가 작습니다. 이는 네트워크 대역폭 사용을 줄이고, 빠른 데이터 전송을 가능하게 합니다.
7. **보안**: gRPC는 기본적으로 SSL/TLS를 사용하여 데이터를 암호화하고, 보안 연결을 통해 통신을 합니다. 이는 데이터 전송 시 보안을 강화합니다.
8. **상태 코드 및 메타데이터 지원**: gRPC는 풍부한 상태 코드와 메타데이터를 지원하여, 오류 처리와 컨텍스트 정보 전달이 용이합니다.

* gRPC는 마이크로서비스, 클라우드 기반 서비스, 모바일 애플리케이션 백엔드, 브라우저 클라이언트 등 다양한 분야에서 사용될 수 있습니다. 특히, 시스템 간의 효율적인 통신이 필요한 곳에서 강점을 발휘합니다. 그러나 gRPC를 사용하기 위해서는 Protocol Buffers와 HTTP/2에 대한 이해가 필요하며, 기존의 HTTP/1.1 기반 인프라와의 통합에 주의를 기울여야 할 수도 있습니다.



## Apache Thrift

* 효율적인, 언어 중립적인 원격 프로시저 호출(RPC) 프레임워크입니다. 이 프레임워크는 Facebook에서 개발되어 2007년에 Apache 소프트웨어 재단의 일부가 되었습니다. Thrift의 주요 목적은 서로 다른 프로그래밍 언어로 작성된 서비스 간의 통신을 용이하게 하는 것입니다.
* Thrift의 주요 특징은 다음과 같습니다.

1. **언어 중립성**: Thrift는 다양한 프로그래밍 언어를 지원합니다. 이는 서비스와 클라이언트가 서로 다른 언어로 작성될 수 있음을 의미합니다. 예를 들어, 서버가 Java로 작성되고 클라이언트가 Python으로 작성될 수 있습니다.
2. **인터페이스 정의 언어(IDL)**: Thrift는 자체 인터페이스 정의 언어를 사용하여 서비스 인터페이스를 정의합니다. 이 IDL은 서비스 메소드, 데이터 타입 및 예외를 명세하는데 사용됩니다.
3. **효율적인 이진 프로토콜**: Thrift는 데이터를 이진 형식으로 직렬화하여 네트워크를 통해 전송합니다. 이는 JSON이나 XML 같은 텍스트 기반 프로토콜보다 효율적일 수 있습니다.
4. **확장성**: Thrift는 확장 가능한 아키텍처를 가지고 있어, 사용자가 필요에 따라 새로운 언어나 프로토콜을 추가할 수 있습니다.
5. **코드 생성**: Thrift는 IDL 파일에서 서버와 클라이언트 코드를 자동으로 생성할 수 있습니다. 이는 서비스 개발을 빠르고 일관성 있게 만들어 줍니다.
6. **다중 트랜스포트 및 프로토콜 지원**: Thrift는 TCP, HTTP와 같은 다양한 트랜스포트와 바이너리, JSON 등 여러 프로토콜을 지원합니다.

* Thrift를 사용하는 주된 이유는 서로 다른 시스템 간의 통신을 간소화하고, 다양한 언어와 플랫폼 간의 호환성을 제공하기 위함입니다. 이는 대규모 분산 시스템, 마이크로서비스 아키텍처, 멀티 언어 환경에서 특히 유용합니다. 예를 들어, 대형 웹 서비스나 내부 시스템 간의 통신에서 Thrift는 서로 다른 언어와 플랫폼 간의 장벽을 낮추고, 개발자가 보다 효율적으로 시스템을 구축할 수 있도록 도와줍니다.
* Thrift의 사용은 특히 서비스의 인터페이스가 자주 변경되지 않고, 여러 언어를 사용하는 대규모 분산 시스템에서 효과적입니다. 그러나, Thrift는 IDL의 사용과 이진 프로토콜의 특성으로 인해, 일부 경우에는 개발 및 디버깅이 더 복잡할 수 있습니다. 따라서, 프로젝트의 요구사항과 환경을 고려하여 Thrift의 사용 여부를 결정하는 것이 중요합니다.



## IDL(Interface Definition Language)

* 서로 다른 프로그래밍 언어로 작성된 소프트웨어 시스템 간의 통신을 가능하게 하는 언어입니다. 주로 분산 시스템이나 네트워크 서비스에서 사용되며, 서비스 인터페이스를 정의하는 데 사용됩니다. IDL은 특정한 프로그래밍 언어에 종속되지 않는, 언어 중립적인 방식으로 인터페이스를 명세합니다.

* IDL의 주요 사용 사례 및 특징은 다음과 같습니다:

1. **언어 중립성**: IDL은 특정 프로그래밍 언어의 구문이나 세부 사항에 의존하지 않습니다. 이로 인해, 서로 다른 프로그래밍 언어로 작성된 시스템 간의 상호 운용성을 보장합니다.
2. **통신 인터페이스 명세**: IDL은 네트워크를 통해 통신하는 시스템 간의 인터페이스를 명확하게 정의합니다. 이것은 메서드, 데이터 타입, 파라미터 등을 포함할 수 있습니다.
3. **분산 시스템의 표준화**: IDL은 CORBA(Common Object Request Broker Architecture), RPC(Remote Procedure Call), 그리고 다양한 웹 서비스 기술에서 사용됩니다. 이를 통해 분산 시스템의 통신을 표준화하고 단순화합니다.
4. **코드 생성**: 많은 IDL 도구는 IDL 파일로부터 서버와 클라이언트 코드를 자동으로 생성할 수 있습니다. 이는 개발자가 네트워크 통신에 필요한 코드를 수동으로 작성하는 노력을 줄여줍니다.
5. **플랫폼 독립성**: IDL을 사용함으로써, 다양한 플랫폼과 환경에서 운영되는 시스템 간의 통신이 용이해집니다.

* IDL의 사용은 특히 대규모 분산 시스템이나 멀티 언어 환경에서 효과적입니다. 예를 들어, 웹 서비스, 클라우드 기반 서비스, 엔터프라이즈 시스템 간의 통신에 널리 사용됩니다. 하지만, IDL의 사용은 추가적인 학습 곡선을 요구하며, 시스템 설계가 IDL 명세에 따라야 한다는 제약이 따릅니다.



## 서비스 메쉬(Service Mesh)

* 마이크로서비스 아키텍처를 위한 인프라 계층으로, 마이크로서비스 간의 네트워크 통신을 관리합니다. 이 인프라 계층은 각 마이크로서비스의 인스턴스와 함께 실행되며, 서비스 간의 모든 네트워크 트래픽을 처리하는 가벼운 프록시로 구성됩니다. 주로 컨테이너화된 환경에서 사용되며, 쿠버네티스(Kubernetes)와 같은 오케스트레이션 시스템과 밀접하게 통합됩니다.

* 서비스 메쉬의 핵심 목적은 마이크로서비스 간의 통신을 보다 효율적이고 안전하게 만드는 것입니다. 이를 통해 개발자들은 비즈니스 로직에 더 집중할 수 있게 되며, 네트워크 관련 문제를 인프라 계층에서 처리할 수 있습니다.

* 서비스 메쉬의 주요 기능은 다음과 같습니다.

1. **로드 밸런싱**: 서비스 간의 트래픽을 자동으로 분산시켜, 시스템의 부하를 균등하게 관리합니다.
2. **서비스 발견**: 마이크로서비스가 네트워크에서 다른 서비스를 찾고 통신할 수 있도록 도와줍니다.
3. **재시도 및 타임아웃**: 네트워크 요청 실패 시 자동으로 재시도하거나, 타임아웃을 설정하여 시스템의 안정성을 높입니다.
4. **암호화 및 보안**: 서비스 간 통신에 SSL/TLS 암호화를 적용하여 데이터 보안을 강화합니다. 또한, 서비스 간 인증 및 권한 부여를 제공하여 보안을 더욱 강화할 수 있습니다.
5. **통신의 모니터링 및 로깅**: 서비스 간의 모든 통신을 모니터링하고 로깅하여, 성능 분석 및 문제 해결에 필요한 데이터를 제공합니다.
6. **유연한 트래픽 관리**: 트래픽 라우팅 규칙을 적용하여 요청을 다양한 방식으로 처리하거나, 서비스 버전 간의 트래픽을 분할하는 등의 기능을 제공합니다.
7. **리스크 감소**: 카나리 배포와 같은 점진적 업데이트를 통해 새로운 서비스 버전을 안전하게 배포하며, 시스템 전체에 영향을 미치지 않으면서 업데이트를 수행할 수 있습니다.

* 이스트리오(Istio), 링커디(Linkerd), 콘스울(Consul) 등 다양한 서비스 메쉬 솔루션이 있으며, 각각의 솔루션은 고유의 특성과 기능을 제공합니다. 서비스 메쉬는 특히 복잡한 마이크로서비스 아키텍처에서 중요한 역할을 하며, 이를 통해 네트워크 관련 운영상의 복잡성을 줄이고, 서비스의 가용성과 성능을 향상시킬 수 있습니다. 하지만, 서비스 메쉬의

* 도입과 운영은 추가적인 복잡성과 관리 부담을 수반할 수 있으므로, 해당 인프라의 도입을 고려할 때는 시스템의 규모와 복잡성, 그리고 팀의 역량을 고려해야 합니다.

* 서비스 메쉬는 분산 시스템의 통신을 단순화하고, 다양한 네트워크 관련 기능들을 표준화함으로써 마이크로서비스 아키텍처의 효율성과 안정성을 크게 향상시킬 수 있습니다. 따라서, 규모가 크고 복잡한 마이크로서비스 기반 애플리케이션을 운영하는 조직에게는 매우 유용한 도구입니다.



## 참고

* ChatGPT-4.0



## 보완/복습

* 2024.01.12 생성
