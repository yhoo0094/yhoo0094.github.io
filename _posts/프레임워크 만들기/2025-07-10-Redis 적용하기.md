---
layout: single
title: "Redis 적용하기"
categories: spring framework
tag: [spring framework]
toc: true
toc_sticky: true
author_profile: false
---

## Docker - Redis 컨테이너 실행(CMD, Power Shell)

```powershell
## Redis 컨테이너 실행
> docker run -d --name redis-local -p 6379:6379 redis
## 정상 실행 확인
> docker ps
> docker exec -it redis-local redis-cli
> ping
PONG ##응답 받으면 정상
```



## Windows - Redis 컨테이너 실행(CMD, Power Shell)

#### WSL2(Ubuntu) 작업

```powershell
## Ubuntu 실행
> wsl -d Ubuntu

# Ubuntu에서 설치/실행
> sudo apt update
> sudo apt install -y redis-server
# 비밀번호/유저 설정 (예시: 사용자 default / 비번 redis)
> sudo sed -i "s/^# *requirepass .*/requirepass redis/" /etc/redis/redis.conf
# Redis 6+ ACL: 사용자 default 활성화 예시(필요 시)
echo 'user default on >redis allchannels allcommands allkeys' | sudo tee -a /etc/redis/redis.conf

# 바인드/보안 (WSL로만 접근이면 기본 설정으로 OK, 외부 바인드 필요 없음)
> sudo systemctl restart redis-server
> sudo systemctl status redis-server
> redis-cli -a redis PING   # PONG 확인

## Ubuntu 나가기
> exit

## Windows → WSL localhost 포워딩 확인
> Test-NetConnection 127.0.0.1 -Port 6379
```

#### Windows ↔ WSL 포트프록시

* **127.0.0.1:6379 → (WSL-IP):6379** 로 전달

```powershell
## powershell에서 진행
# Set-WSLPortProxy.ps1 (요지)
param(
  [string]$Distro = "Ubuntu",
  [string]$ListenAddress = "127.0.0.1",
  [int]$ListenPort = 6379,
  [int]$ConnectPort = 6379
)

function Require-Admin {
  $id=[Security.Principal.WindowsIdentity]::GetCurrent()
  $p=New-Object Security.Principal.WindowsPrincipal($id)
  if(-not $p.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)){
    throw "관리자 PowerShell에서 실행하세요."
  }
}

function Get-WSLIPv4([string]$d){
  $cmd="ip -4 route get 8.8.8.8 | sed -n 's/.*src \([0-9.]\+\).*/\1/p'"
  $ip=(wsl -d $d bash -lc $cmd) -replace '\s',''
  if([string]::IsNullOrWhiteSpace($ip)){
    $cmd2="ip -4 -o addr show dev eth0 | awk '{print $4}' | cut -d/ -f1"
    $ip=(wsl -d $d bash -lc $cmd2) -replace '\s',''
  }
  $ip
}

function Ensure-Service {
  $svc=Get-Service iphlpsvc
  if($svc.Status -ne 'Running'){ Start-Service iphlpsvc }
}

function Set-PortProxy($listenAddr,$listenPort,$connectAddr,$connectPort){
  netsh interface portproxy delete v4tov4 listenaddress=$listenAddr listenport=$listenPort 2>$null | Out-Null
  netsh interface portproxy add v4tov4 listenaddress=$listenAddr listenport=$listenPort connectaddress=$connectAddr connectport=$connectPort
}

function Set-Firewall($ruleName,$port){
  if(-not (Get-NetFirewallRule -DisplayName $ruleName -ErrorAction SilentlyContinue)){
    New-NetFirewallRule -DisplayName $ruleName -Direction Inbound -Action Allow -Protocol TCP -LocalPort $port | Out-Null
  }
}

# 실행
Require-Admin
Ensure-Service
$wslIp = Get-WSLIPv4 -d $Distro
Set-PortProxy -listenAddr $ListenAddress -listenPort $ListenPort -connectAddr $wslIp -connectPort $ConnectPort
Set-Firewall -ruleName "WSL PortProxy $ListenPort" -port $ListenPort

# 확인
netsh interface portproxy show all
Test-NetConnection 127.0.0.1 -Port 6379
```

#### 자동 갱신(스케줄러)

```powershell
$scriptPath = "C:\Tools\Set-WSLPortProxy.ps1"
$taskName   = "WSL PortProxy Auto-Refresh"
$action     = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`" -Distro `"Ubuntu`" -ListenPort 6379 -ConnectPort 6379"
$trigger    = New-ScheduledTaskTrigger -AtLogOn
Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -RunLevel Highest -Description "Refresh WSL portproxy for Redis" -Force
# 수동 테스트
Start-ScheduledTask -TaskName $taskName
```

#### portproxy가 살아있는지 다시 확인/복구

```powershell
netsh interface portproxy show all
# 목록이 비었거나 6379가 없으면 다시 등록
netsh interface portproxy delete v4tov4 listenaddress=127.0.0.1 listenport=6379 2>$null | Out-Null
netsh interface portproxy add v4tov4 listenaddress=127.0.0.1 listenport=6379 connectaddress=172.20.75.0 connectport=6379
Get-Service iphlpsvc | Set-Service -StartupType Automatic
Start-Service iphlpsvc

# 테스트
Test-NetConnection 127.0.0.1 -Port 6379
# -> TcpTestSucceeded : True 가 되어야 정상
```

#### WSL 쪽 Redis가 실제로 LISTEN 중인지 확인

```powershell
ss -ltnp | grep 6379
# 0.0.0.0:6379 (또는 172.20.75.0:6379) 로 LISTEN 중이어야 함
redis-cli -h 172.20.75.0 -p 6379 -a redis ping
# -> PONG
```



## Spring Boot에서 Redis 연결 설정

* pom.xml 수정

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

* application.properties 수정


```xml
spring.data.redis.host=127.0.0.1
spring.data.redis.port=6379
spring.data.redis.username=default
spring.data.redis.password=redis
spring.data.redis.timeout=3s
```

* 의존성 주입을 위한 Repository 클래스 생성

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.HashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public class RedisPermissionRepository {

    private final HashOperations<String, String, String> hashOperations;

    @Autowired
    public RedisPermissionRepository(RedisTemplate<String, String> redisTemplate) {
        this.hashOperations = redisTemplate.opsForHash();
    }

    // 권한 저장
    public void savePermission(String userId, String path, int level) {
        String key = getKey(userId);
        hashOperations.put(key, path, String.valueOf(level));
    }

    // 권한 조회
    public Optional<Integer> getPermission(String userId, String path) {
        String key = getKey(userId);
        String value = hashOperations.get(key, path);
        return Optional.ofNullable(value).map(Integer::valueOf);
    }

    // 전체 권한 삭제 (ex. 로그아웃 또는 권한 변경 시)
    public void deleteAllPermissions(String userId) {
        String key = getKey(userId);
        hashOperations.getOperations().delete(key);
    }

    private String getKey(String userId) {
        return "perm:" + userId;
    }
}
```



## 참고

* Chat GPT 4.0
